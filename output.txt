===== ./src/authentication/auth/authenticate.sh =====
#!/bin/bash

authenticate_user(){
    local username="$1"
    local password="$2"
    
    local record=$(get_user_record "$username")
    
    if [[ -z "$record" ]]; then
        show_error "Invalid username or password"
        log_auth "$username" "failed"
        return 1
    fi
    
    local stored_hash=$(get_user_password_hash "$username")
    local status=$(get_user_status "$username")
    
    if [[ "$status" != "active" ]]; then
        show_error "Account is disabled"
        log_auth "$username" "failed_disabled"
        return 1
    fi
    
    if ! verify_password "$password" "$stored_hash"; then
        show_error "Invalid username or password"
        log_auth "$username" "failed"
        return 1
    fi
    
    log_auth "$username" "success"
    return 0
}

login_interactive() {
    echo ""
    read -p "Username: " username
    read -s -p "Password: " password
    echo ""
    
    if authenticate_user "$username" "$password"; then
        local session_token=$(create_session "$username")
        show_success "Welcome, $username!"
        return 0
    else
        return 1
    fi
}
===== ./src/authentication/auth/change_password.sh =====
#!/bin/bash

change_password(){
    local username="$1"
    local old_password="$2"
    local new_password="$3"
    
    if ! authenticate_user "$username" "$old_password"; then
        show_error "Current password is incorrect"
        return 1
    fi
    
    validate_password "$new_password" || return 1
    
    local new_hash=$(hash_password "$new_password")
    
    update_user_password "$username" "$new_hash"
    
    show_success "Password changed successfully"
    log_user_action "PASSWORD_CHANGED" "username=$username"
    return 0
}
===== ./src/authentication/auth/password.sh =====
#!/bin/bash

hash_password() {
    local password="$1"
    echo -n "$password" | sha256sum | cut -d' ' -f1
}

#Validate password
validate_password() {
    local password="$1"
    
    #Check minimum length
    if [[ ${#password} -lt $MIN_PASSWORD_LENGTH ]]; then
        show_error "Password must be at least $MIN_PASSWORD_LENGTH characters"
        return 1
    fi
    
    return 0
}

#Verify password against hash
verify_password() {
    local password="$1"
    local stored_hash="$2"
    
    local password_hash=$(hash_password "$password")
    
    [[ "$password_hash" == "$stored_hash" ]]
}
===== ./src/authentication/auth/register.sh =====
#!/bin/bash

#username|password_hash|email|role|created_at|status
register_user() {
    local username="$1"
    local password="$2"
    local email="$3"
    local role="${4:-$ROLE_USER}"
    
    validate_username "$username" || return 1
    validate_password "$password" || return 1
    validate_email "$email" || return 1
    
    if user_exists "$username"; then
        show_error "Username '$username' already exists"
        log_user_action "REGISTER_FAILED" "username=$username reason=already_exists"
        return 1
    fi
    
    local password_hash=$(hash_password "$password")
    
    create_user_record "$username" "$password_hash" "$email" "$role"
    
    log_user_action "USER_REGISTERED" "username=$username role=$role email=$email"
    return 0
}
===== ./src/authentication/auth/role_check.sh =====
#!/bin/bash

is_admin() {
    local username="${1:-$CURRENT_USER}"
    local role=$(get_user_role "$username")
    [[ "$role" == "$ROLE_ADMIN" ]]
}

require_auth(){
    if [[ -z "$CURRENT_USER" ]]; then
        show_error "You must be logged in to perform this action"
        return 1
    fi
    return 0
}

require_admin(){
    require_auth || return 1
    
    if ! is_admin; then
        show_error "This action requires administrator privileges"
        log_user_action "UNAUTHORIZED_ACCESS_ATTEMPT" "username=$CURRENT_USER required_role=admin"
        return 1
    fi
    
    return 0
}
===== ./src/authentication/auth/session.sh =====
#!/bin/bash

generate_session_token(){
    echo "$(date +%s)_$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32)"
}

create_session(){
    local username="$1"
    
    local session_token=$(generate_session_token)
    local created_at=$(date '+%Y-%m-%d %H:%M:%S')
    local expires_at=$(date -d '+24 hours' '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date -v+24H '+%Y-%m-%d %H:%M:%S')
    
    #session_token|username|created_at|expires_at|status
    local session_record="${session_token}${FIELD_DELIMITER}${username}${FIELD_DELIMITER}${created_at}${FIELD_DELIMITER}${expires_at}${FIELD_DELIMITER}active"
    
    echo "$session_record" >> "$SESSIONS_FILE"
    
    export CURRENT_SESSION="$session_token"
    export CURRENT_USER="$username"
    
    log_user_action "SESSION_CREATED" "username=$username"
    echo "$session_token"
}

get_session_record(){
    local session_token="$1"
    
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        return 1
    fi
    
    grep "^${session_token}${FIELD_DELIMITER}" "$SESSIONS_FILE" | tail -1
}

validate_session(){
    local session_token="$1"
    
    if [[ ! -f "$SESSIONS_FILE" ]]; then
        return 1
    fi
    
    local record=$(get_session_record "$session_token")
    
    if [[ -z "$record" ]]; then
        return 1
    fi
    
    local username=$(echo "$record" | cut -d"$FIELD_DELIMITER" -f2)
    local expires_at=$(echo "$record" | cut -d"$FIELD_DELIMITER" -f4)
    local status=$(echo "$record" | cut -d"$FIELD_DELIMITER" -f5)
    
    if [[ "$status" != "active" ]]; then
        return 1
    fi
    
    local current_time=$(date '+%s')
    local expire_time=$(date -d "$expires_at" '+%s' 2>/dev/null || date -j -f '%Y-%m-%d %H:%M:%S' "$expires_at" '+%s')
    
    if [[ $current_time -gt $expire_time ]]; then
        return 1
    fi
    
    export CURRENT_SESSION="$session_token"
    export CURRENT_USER="$username"
    
    return 0
}

invalidate_session(){
    local session_token="$1"
    
    if [[ -z "$session_token" ]]; then
        return 1
    fi
    
    if [[ -f "$SESSIONS_FILE" ]]; then
        sed -i.bak "s/^\(${session_token}${FIELD_DELIMITER}[^${FIELD_DELIMITER}]*${FIELD_DELIMITER}[^${FIELD_DELIMITER}]*${FIELD_DELIMITER}[^${FIELD_DELIMITER}]*${FIELD_DELIMITER}\)active$/\1inactive/" "$SESSIONS_FILE"
    fi
}

logout_user(){
    local session_token="${1:-$CURRENT_SESSION}"
    
    if [[ -z "$session_token" ]]; then
        show_error "No active session"
        return 1
    fi
    
    invalidate_session "$session_token"
    
    log_user_action "LOGOUT" "username=$CURRENT_USER"
    
    export CURRENT_SESSION=""
    export CURRENT_USER=""
    
    show_success "Logged out successfully"
    return 0
}
===== ./src/authentication/auth/user_data.sh =====
#!/bin/bash

user_exists(){
    local username="$1"
    
    if [[ ! -f "$USERS_FILE" ]]; then
        return 1
    fi
    
    grep -q "^${username}${FIELD_DELIMITER}" "$USERS_FILE"
}

get_user_record(){
    local username="$1"
    
    if [[ ! -f "$USERS_FILE" ]]; then
        return 1
    fi
    
    grep "^${username}${FIELD_DELIMITER}" "$USERS_FILE"
}

#1=username - 2=password_hash - 3=email - 4=role - 5=created_at - 6=status
get_user_field(){
    local username="$1"
    local field_index="$2"
    
    local record=$(get_user_record "$username")
    
    if [[ -z "$record" ]]; then
        return 1
    fi
    
    echo "$record" | cut -d"$FIELD_DELIMITER" -f"$field_index"
}

get_user_password_hash(){
    local username="$1"
    get_user_field "$username" 2
}

get_user_email(){
    local username="$1"
    get_user_field "$username" 3
}

get_user_role(){
    local username="${1:-$CURRENT_USER}"
    get_user_field "$username" 4
}

get_user_status(){
    local username="$1"
    get_user_field "$username" 6
}

#username|password_hash|email|role|created_at|status
create_user_record(){
    local username="$1"
    local password_hash="$2"
    local email="$3"
    local role="$4"
    
    local created_at=$(date '+%Y-%m-%d %H:%M:%S')
    local status="active"
    
    local user_record="${username}${FIELD_DELIMITER}${password_hash}${FIELD_DELIMITER}${email}${FIELD_DELIMITER}${role}${FIELD_DELIMITER}${created_at}${FIELD_DELIMITER}${status}"
    
    echo "$user_record" >> "$USERS_FILE"
}

update_user_password(){
    local username="$1"
    local new_hash="$2"
    
    if [[ ! -f "$USERS_FILE" ]]; then
        return 1
    fi
    
    local record=$(get_user_record "$username")
    local email=$(echo "$record" | cut -d"$FIELD_DELIMITER" -f3)
    local role=$(echo "$record" | cut -d"$FIELD_DELIMITER" -f4)
    local created_at=$(echo "$record" | cut -d"$FIELD_DELIMITER" -f5)
    local status=$(echo "$record" | cut -d"$FIELD_DELIMITER" -f6)
    
    local new_record="${username}${FIELD_DELIMITER}${new_hash}${FIELD_DELIMITER}${email}${FIELD_DELIMITER}${role}${FIELD_DELIMITER}${created_at}${FIELD_DELIMITER}${status}"
    
    #Replace old record with new one
    sed -i.bak "s|^${username}${FIELD_DELIMITER}.*|${new_record}|" "$USERS_FILE"
}

update_user_status(){
    local username="$1"
    local new_status="$2"
    
    if [[ ! -f "$USERS_FILE" ]]; then
        return 1
    fi
    
    #Replace status field
    sed -i.bak "s/^\(${username}${FIELD_DELIMITER}[^${FIELD_DELIMITER}]*${FIELD_DELIMITER}[^${FIELD_DELIMITER}]*${FIELD_DELIMITER}[^${FIELD_DELIMITER}]*${FIELD_DELIMITER}[^${FIELD_DELIMITER}]*${FIELD_DELIMITER}\)[^${FIELD_DELIMITER}]*$/\1${new_status}/" "$USERS_FILE"
}
===== ./src/authentication/auth/user_management.sh =====
#!/bin/bash

list_users(){
    require_admin || return 1
    
    if [[ ! -f "$USERS_FILE" || ! -s "$USERS_FILE" ]]; then
        show_info "No users found"
        return 0
    fi
    
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "%-20s %-30s %-10s %-10s\n" "USERNAME" "EMAIL" "ROLE" "STATUS"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    while IFS="$FIELD_DELIMITER" read -r username _ email role _ status; do
        printf "%-20s %-30s %-10s %-10s\n" "$username" "$email" "$role" "$status"
    done < "$USERS_FILE"
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    
    log_user_action "LIST_USERS" "by=$CURRENT_USER"
}

disable_user(){
    local target_user="$1"
    
    require_admin || return 1
    
    if [[ "$target_user" == "$CURRENT_USER" ]]; then
        show_error "You cannot disable your own account"
        return 1
    fi
    
    if ! user_exists "$target_user"; then
        show_error "User '$target_user' not found"
        return 1
    fi
    
    update_user_status "$target_user" "disabled"
    
    show_success "User '$target_user' has been disabled"
    log_user_action "USER_DISABLED" "by=$CURRENT_USER target=$target_user"
}

enable_user(){
    local target_user="$1"
    
    require_admin || return 1
    
    if ! user_exists "$target_user"; then
        show_error "User '$target_user' not found"
        return 1
    fi
    
    update_user_status "$target_user" "active"
    
    show_success "User '$target_user' has been enabled"
    log_user_action "USER_ENABLED" "by=$CURRENT_USER target=$target_user"
}
===== ./src/authentication/auth/validation.sh =====
#!/bin/bash

validate_username() {
    local username="$1"
    
    if [[ ${#username} -lt $MIN_USERNAME_LENGTH ]]; then
        show_error "Username must be at least $MIN_USERNAME_LENGTH characters"
        return 1
    fi
    
    if [[ ${#username} -gt $MAX_USERNAME_LENGTH ]]; then
        show_error "Username must be at most $MAX_USERNAME_LENGTH characters"
        return 1
    fi
    
    if [[ ! "$username" =~ ^[a-zA-Z0-9_]+$ ]]; then
        show_error "Username can only contain letters, numbers, and underscores"
        return 1
    fi
    
    return 0
}

validate_email() {
    local email="$1"
    
    if [[ ! "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        show_error "Invalid email format"
        return 1
    fi
    
    return 0
}
===== ./src/authentication/auth.sh =====
#!/bin/bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

source "$SCRIPT_DIR/auth/validation.sh"
source "$SCRIPT_DIR/auth/password.sh"
source "$SCRIPT_DIR/auth/user_data.sh"

source "$SCRIPT_DIR/auth/session.sh"

source "$SCRIPT_DIR/auth/register.sh"
source "$SCRIPT_DIR/auth/authenticate.sh"
source "$SCRIPT_DIR/auth/change_password.sh"

source "$SCRIPT_DIR/auth/role_check.sh"

source "$SCRIPT_DIR/auth/user_management.sh"
===== ./src/authentication/authorization/grant.sh =====
#!/bin/bash

validate_permission_type(){
    local permission="$1"
    
    case "$permission" in
        "$PERM_SELECT"|"$PERM_INSERT"|"$PERM_UPDATE"|"$PERM_DELETE"|"$PERM_ALL")
            return 0
            ;;
        *)
            show_error "Invalid permission: $permission"
            return 1
            ;;
    esac
}

grant_permission(){
    local target_user="$1"
    local db_name="$2"
    local table_name="$3"
    local permission="$4"
    
    require_auth || return 1
    
    if ! is_admin && ! is_db_owner "$db_name"; then
        show_error "Only database owner or admin can grant permissions"
        return 1
    fi
    
    validate_permission_type "$permission" || return 1
    
    if ! user_exists "$target_user"; then
        show_error "User '$target_user' does not exist"
        return 1
    fi
    
    init_db_permissions "$db_name"
    
    if permission_exists "$db_name" "$target_user" "$table_name" "$permission"; then
        show_warning "Permission already granted"
        return 0
    fi
    
    add_permission_record "$db_name" "$target_user" "$table_name" "$permission"
    
    show_success "Permission granted: $permission on $db_name${table_name:+.$table_name} to $target_user"
    log_user_action "GRANT_PERMISSION" "by=$CURRENT_USER to=$target_user db=$db_name table=$table_name perm=$permission"
    
    return 0
}

grant_all_on_db(){
    local target_user="$1"
    local db_name="$2"
    
    grant_permission "$target_user" "$db_name" "" "$PERM_ALL"
}

grant_all_on_table(){
    local target_user="$1"
    local db_name="$2"
    local table_name="$3"
    
    grant_permission "$target_user" "$db_name" "$table_name" "$PERM_ALL"
}
===== ./src/authentication/authorization/list_perms.sh =====
#!/bin/bash

list_db_permissions(){
    local db_name="$1"
    
    require_auth || return 1

    if ! is_admin && ! is_db_owner "$db_name"; then
        show_error "Only database owner or admin can view permissions"
        return 1
    fi
    
    local perm_file=$(get_permissions_file "$db_name")
    
    if [[ ! -f "$perm_file" || ! -s "$perm_file" ]]; then
        show_info "No permissions granted for database '$db_name'"
        return 0
    fi
    
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Permissions for database: $db_name"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "%-15s %-20s %-15s %-15s\n" "USERNAME" "DATABASE" "TABLE" "PERMISSION"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    while IFS="$FIELD_DELIMITER" read -r username database table permission; do
        [[ "$database" == "$db_name" ]] || continue
        local table_display="${table:-*}"
        printf "%-15s %-20s %-15s %-15s\n" "$username" "$database" "$table_display" "$permission"
    done < "$perm_file"
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    
    log_user_action "LIST_PERMISSIONS" "db=$db_name by=$CURRENT_USER"
}

list_user_permissions(){
    local target_user="${1:-$CURRENT_USER}"
    
    require_auth || return 1
    
    if [[ "$target_user" != "$CURRENT_USER" ]] && ! is_admin; then
        show_error "You can only view your own permissions"
        return 1
    fi
    
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Permissions for user: $target_user"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "%-20s %-15s %-15s\n" "DATABASE" "TABLE" "PERMISSION"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    local found=0
    
    for db_path in "$DB_DIR"/*/; do
        [[ -d "$db_path" ]] || continue
        
        local db_name=$(basename "$db_path")
        local perm_file=$(get_permissions_file "$db_name")
        
        [[ -f "$perm_file" ]] || continue
        
        while IFS="$FIELD_DELIMITER" read -r username database table permission; do
            if [[ "$username" == "$target_user" ]]; then
                local table_display="${table:-*}"
                printf "%-20s %-15s %-15s\n" "$database" "$table_display" "$permission"
                found=1
            fi
        done < "$perm_file"
    done
    
    if [[ $found -eq 0 ]]; then
        echo "No explicit permissions granted"
    fi
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
}
===== ./src/authentication/authorization/ownership.sh =====
#!/bin/bash

set_db_owner() {
    local db_name="$1"
    local owner="${2:-$CURRENT_USER}"
    
    local db_path="$DB_DIR/$db_name"
    
    if [[ ! -d "$db_path" ]]; then
        show_error "Database '$db_name' does not exist"
        return 1
    fi
    
    echo "$owner" > "$db_path/.owner"
    log_db_op "SET_OWNER" "$db_name" "" "owner=$owner"
    return 0
}

get_db_owner() {
    local db_name="$1"
    local owner_file="$DB_DIR/$db_name/.owner"
    
    if [[ -f "$owner_file" ]]; then
        cat "$owner_file"
    else
        echo ""
    fi
}

is_db_owner() {
    local db_name="$1"
    local username="${2:-$CURRENT_USER}"
    
    local owner=$(get_db_owner "$db_name")
    
    [[ "$owner" == "$username" ]]
}

can_access_db(){
    local db_name="$1"
    local username="${2:-$CURRENT_USER}"
    
    if is_admin "$username"; then
        return 0
    fi
    
    if is_db_owner "$db_name" "$username"; then
        return 0
    fi
    
    if has_db_permission "$db_name" "$username" "$PERM_SELECT"; then
        return 0
    fi
    
    return 1
}
===== ./src/authentication/authorization/perm_check.sh =====
#!/bin/bash

has_permission(){
    local username="$1"
    local db_name="$2"
    local table_name="$3"
    local required_perm="$4"
    
    if is_admin "$username"; then
        return 0
    fi
    
    if is_db_owner "$db_name" "$username"; then
        return 0
    fi
    
    local perm_file=$(get_permissions_file "$db_name")
    
    if [[ ! -f "$perm_file" ]]; then
        return 1
    fi
    
    if grep -q "^${username}${FIELD_DELIMITER}${db_name}${FIELD_DELIMITER}${FIELD_DELIMITER}${PERM_ALL}$" "$perm_file"; then
        return 0
    fi
    
    if [[ -n "$table_name" ]]; then
        if grep -q "^${username}${FIELD_DELIMITER}${db_name}${FIELD_DELIMITER}${table_name}${FIELD_DELIMITER}${PERM_ALL}$" "$perm_file"; then
            return 0
        fi
    fi
    
    if grep -q "^${username}${FIELD_DELIMITER}${db_name}${FIELD_DELIMITER}${FIELD_DELIMITER}${required_perm}$" "$perm_file"; then
        return 0
    fi
    
    if [[ -n "$table_name" ]]; then
        if grep -q "^${username}${FIELD_DELIMITER}${db_name}${FIELD_DELIMITER}${table_name}${FIELD_DELIMITER}${required_perm}$" "$perm_file"; then
            return 0
        fi
    fi
    
    return 1
}

has_db_permission(){
    local db_name="$1"
    local username="${2:-$CURRENT_USER}"
    local permission="${3:-$PERM_SELECT}"
    
    has_permission "$username" "$db_name" "" "$permission"
}

has_table_permission(){
    local db_name="$1"
    local table_name="$2"
    local username="${3:-$CURRENT_USER}"
    local permission="${4:-$PERM_SELECT}"
    
    has_permission "$username" "$db_name" "$table_name" "$permission"
}

require_permission(){
    local db_name="$1"
    local table_name="$2"
    local permission="$3"
    
    require_auth || return 1
    
    if ! has_permission "$CURRENT_USER" "$db_name" "$table_name" "$permission"; then
        show_error "Permission denied: $permission required on $db_name${table_name:+.$table_name}"
        log_user_action "PERMISSION_DENIED" "user=$CURRENT_USER db=$db_name table=$table_name perm=$permission"
        return 1
    fi
    
    return 0
}
===== ./src/authentication/authorization/perm_data.sh =====
#!/bin/bash

init_db_permissions(){
    local db_name="$1"
    local metadata_dir="$DB_DIR/$db_name/.metadata"
    
    mkdir -p "$metadata_dir"
    
    local perm_file="$metadata_dir/.permissions"
    
    if [[ ! -f "$perm_file" ]]; then
        touch "$perm_file"
    fi
}

get_permissions_file(){
    local db_name="$1"
    echo "$DB_DIR/$db_name/.metadata/.permissions"
}

add_permission_record(){
    local db_name="$1"
    local username="$2"
    local table_name="$3"
    local permission="$4"
    
    local perm_file=$(get_permissions_file "$db_name")
    local perm_record="${username}${FIELD_DELIMITER}${db_name}${FIELD_DELIMITER}${table_name}${FIELD_DELIMITER}${permission}"
    
    echo "$perm_record" >> "$perm_file"
}

remove_permission_record(){
    local db_name="$1"
    local username="$2"
    local table_name="$3"
    local permission="$4"
    
    local perm_file=$(get_permissions_file "$db_name")
    local perm_pattern="^${username}${FIELD_DELIMITER}${db_name}${FIELD_DELIMITER}${table_name}${FIELD_DELIMITER}${permission}$"
    
    sed -i.bak "/${perm_pattern}/d" "$perm_file"
}

permission_exists(){
    local db_name="$1"
    local username="$2"
    local table_name="$3"
    local permission="$4"
    
    local perm_file=$(get_permissions_file "$db_name")
    
    if [[ ! -f "$perm_file" ]]; then
        return 1
    fi
    
    local perm_pattern="^${username}${FIELD_DELIMITER}${db_name}${FIELD_DELIMITER}${table_name}${FIELD_DELIMITER}${permission}$"
    
    grep -q "$perm_pattern" "$perm_file"
}

remove_all_user_permissions(){
    local db_name="$1"
    local username="$2"
    
    local perm_file=$(get_permissions_file "$db_name")
    
    if [[ ! -f "$perm_file" ]]; then
        return 1
    fi
    
    sed -i.bak "/^${username}${FIELD_DELIMITER}${db_name}${FIELD_DELIMITER}/d" "$perm_file"
}
===== ./src/authentication/authorization/revoke.sh =====
#!/bin/bash

revoke_permission(){
    local target_user="$1"
    local db_name="$2"
    local table_name="$3"
    local permission="$4"
    
    require_auth || return 1
    
    if ! is_admin && ! is_db_owner "$db_name"; then
        show_error "Only database owner or admin can revoke permissions"
        return 1
    fi
    
    local perm_file=$(get_permissions_file "$db_name")
    
    if [[ ! -f "$perm_file" ]]; then
        show_error "No permissions found for database '$db_name'"
        return 1
    fi
    
    remove_permission_record "$db_name" "$target_user" "$table_name" "$permission"
    
    show_success "Permission revoked: $permission on $db_name${table_name:+.$table_name} from $target_user"
    log_user_action "REVOKE_PERMISSION" "by=$CURRENT_USER from=$target_user db=$db_name table=$table_name perm=$permission"
    
    return 0
}

revoke_all_from_db(){
    local target_user="$1"
    local db_name="$2"
    
    require_auth || return 1
    
    if ! is_admin && ! is_db_owner "$db_name"; then
        show_error "Only database owner or admin can revoke permissions"
        return 1
    fi
    
    local perm_file=$(get_permissions_file "$db_name")
    
    if [[ ! -f "$perm_file" ]]; then
        show_error "No permissions found for database '$db_name'"
        return 1
    fi
    
    remove_all_user_permissions "$db_name" "$target_user"
    
    show_success "All permissions revoked from $target_user on database $db_name"
    log_user_action "REVOKE_ALL_PERMISSIONS" "by=$CURRENT_USER from=$target_user db=$db_name"
}
===== ./src/authentication/authorization.sh =====

===== ./src/config/colors.conf =====
export COLOR_RED='\033[0;31m'
export COLOR_GREEN='\033[0;32m'
export COLOR_YELLOW='\033[1;33m'
export COLOR_BLUE='\033[0;34m'
export COLOR_RESET='\033[0m'
===== ./src/config/limits.conf =====
export FIELD_DELIMITER="|"
export RECORD_DELIMITER=$'\n'

export MAX_USERNAME_LENGTH=20
export MIN_USERNAME_LENGTH=3
export MIN_PASSWORD_LENGTH=6
===== ./src/config/load.conf =====
source "$(dirname "${BASH_SOURCE[0]}")/paths.conf"
source "$(dirname "${BASH_SOURCE[0]}")/users.conf"
source "$(dirname "${BASH_SOURCE[0]}")/logs.conf"
source "$(dirname "${BASH_SOURCE[0]}")/limits.conf"
source "$(dirname "${BASH_SOURCE[0]}")/roles.conf"
source "$(dirname "${BASH_SOURCE[0]}")/permissions.conf"
source "$(dirname "${BASH_SOURCE[0]}")/colors.conf"
source "$(dirname "${BASH_SOURCE[0]}")/session.conf"
===== ./src/config/logs.conf =====
export LOG_DIR="$STORAGE_DIR/logs"
export AUDIT_LOG="$LOG_DIR/audit.log"
export ERROR_LOG="$LOG_DIR/error.log"
export ACCESS_LOG="$LOG_DIR/access.log"

===== ./src/config/paths.conf =====
#Root Path Resolution
export PENGUIN_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

export STORAGE_DIR="$PENGUIN_ROOT/storage"
export DB_DIR="$STORAGE_DIR/databases"
export TEMP_DIR="$STORAGE_DIR/temp"
===== ./src/config/permissions.conf =====
export PERM_SELECT="SELECT"
export PERM_INSERT="INSERT"
export PERM_UPDATE="UPDATE"
export PERM_DELETE="DELETE"
export PERM_ALL="ALL"
===== ./src/config/roles.conf =====
export ROLE_ADMIN="admin"
export ROLE_USER="user"
export ROLE_GUEST="guest"
===== ./src/config/session.conf =====
export CURRENT_USER=""
export CURRENT_SESSION=""
export CURRENT_DB=""
export CURRENT_TABLE=""

===== ./src/config/users.conf =====
export USER_DIR="$STORAGE_DIR/users"
export USERS_FILE="$USER_DIR/users.dat"
export SESSIONS_FILE="$USER_DIR/sessions.dat"

===== ./src/init/first_run.sh =====
#!/bin/bash

show_welcome(){
    clear
    echo "╔════════════════════════════════════════╗"
    echo "║                                        ║"
    echo "║           Welcome to PenguinDB         ║"
    echo "║                                        ║"
    echo "║  A Database Management System in Bash  ║"
    echo "║                                        ║"
    echo "╚════════════════════════════════════════╝"
    echo ""
    echo "First time setup required..."
    echo ""
}

run_first_time_setup(){
    show_info "Creating admin account..."
    echo ""
    
    read -p "Admin username: " admin_user
    read -s -p "Admin password: " admin_pass
    echo ""
    read -s -p "Confirm password: " admin_pass2
    echo ""
    
    if [[ "$admin_pass" != "$admin_pass2" ]]; then
        show_error "Passwords don't match!"
        exit 1
    fi
    
    register_user "$admin_user" "$admin_pass" "admin@dbms.local" "admin"
    
    show_success "Admin account created successfully!"
    echo ""
    read -p "Press Enter to continue..."
}
===== ./src/init/sample.sh =====

===== ./src/init/setup.sh =====

===== ./src/logger.sh =====
#!/bin/bash

log_audit() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[${timestamp}] ${message}" >> "$AUDIT_LOG"
}

log_error() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[${timestamp}] ${message}" >> "$ERROR_LOG"
}

log_access() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[${timestamp}] ${message}" >> "$ACCESS_LOG"
}

show_info() {
    echo -e "${COLOR_BLUE}[INFO]${COLOR_RESET} $1"
    log_audit "INFO: $1"
}

show_success() {
    echo -e "${COLOR_GREEN}✓ $1${COLOR_RESET}"
    log_audit "SUCCESS: $1"
}

show_warning() {
    echo -e "${COLOR_YELLOW}[WARNING]${COLOR_RESET} $1"
    log_audit "WARNING: $1"
}

show_error() {
    echo -e "${COLOR_RED}✗ $1${COLOR_RESET}"
    log_error "ERROR: $1"
}

log_auth() {
    local username="$1"
    local status="$2"
    log_access "AUTH: user=$username status=$status"
}

log_db_op() {
    local operation="$1"
    local database="$2"
    local table="$3"
    local user="${CURRENT_USER:-guest}"
    
    local msg="DB_OP: user=$user op=$operation db=$database"
    [[ -n "$table" ]] && msg="$msg table=$table"
    
    log_audit "$msg"
}

log_user_action() {
    local action="$1"
    local details="$2"
    local user="${CURRENT_USER:-guest}"
    
    local msg="USER_ACTION: user=$user action=$action"
    [[ -n "$details" ]] && msg="$msg details=$details"
    
    log_audit "$msg"
}
